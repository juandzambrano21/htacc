"""
catbp/topology/homology.py

Homology computation for determining essential chords.

Uses GF(2) linear algebra to:
1. Compute boundary subspace from triangles
2. Identify chords whose fundamental cycles are non-trivial in H1
"""

from __future__ import annotations

from typing import Any, Dict, Iterable, List, Tuple

import networkx as nx

Node = Any
Edge = Tuple[Node, Node]  # Undirected canonical (u < v)


def _canon_edge(u: Node, v: Node) -> Edge:
    """Return canonical edge representation with u <= v."""
    return (u, v) if u <= v else (v, u)


def _gf2_reduce(v: int, pivots: Dict[int, int]) -> int:
    """
    Reduce bitvector v by a pivot dictionary: pivot_bit -> basis_vector (with that pivot).
    Uses MSB pivoting.
    """
    while v:
        p = v.bit_length() - 1
        b = pivots.get(p)
        if b is None:
            break
        v ^= b
    return v


def _gf2_insert(v: int, pivots: Dict[int, int]) -> bool:
    """
    Insert v into pivot basis if independent. Returns True iff inserted.
    """
    v = _gf2_reduce(v, pivots)
    if v == 0:
        return False
    p = v.bit_length() - 1
    pivots[p] = v
    return True


def _edge_index(nerve_edges: Iterable[Edge]) -> Dict[Edge, int]:
    """Create index mapping from edges to bit positions."""
    edges = sorted(set(nerve_edges))
    return {e: i for i, e in enumerate(edges)}


def _triangle_boundary_vec(tri: Tuple[Node, Node, Node], e2i: Dict[Edge, int]) -> int:
    """
    Compute boundary of a triangle as a GF(2) edge vector.
    
    The boundary of triangle (a, b, c) is the sum of its three edges.
    """
    a, b, c = tri
    v = 0
    for edge in [_canon_edge(a, b), _canon_edge(b, c), _canon_edge(a, c)]:
        idx = e2i.get(edge)
        if idx is None:
            # If the graph is missing an edge, the 2-simplex isn't valid as a filler
            return 0
        v ^= (1 << idx)
    return v


def _fundamental_cycle_vec(
    tree: nx.Graph,
    chord: Edge,
    e2i: Dict[Edge, int],
) -> int:
    """
    Compute fundamental cycle of chord relative to tree as a GF(2) edge-vector.
    
    The fundamental cycle consists of the chord plus the unique tree path
    connecting its endpoints.
    
    Args:
        tree: Spanning tree of the nerve
        chord: Edge (u, v) not in tree but in nerve
        e2i: Edge to index mapping
        
    Returns:
        Bitvector representing the cycle
    """
    u, v = chord
    path = nx.shortest_path(tree, source=u, target=v)  # nodes
    vbits = 0
    
    # Tree path edges
    for i in range(len(path) - 1):
        e = _canon_edge(path[i], path[i + 1])
        vbits ^= (1 << e2i[e])
    
    # Chord edge
    vbits ^= (1 << e2i[chord])
    return vbits


def nontrivial_h1_chords(
    *,
    tree: nx.Graph,
    nerve: nx.Graph,
    triangles: Iterable[Tuple[Node, Node, Node]],
) -> List[Edge]:
    """
    Find chords whose fundamental cycles are non-trivial in H1.
    
    A chord is non-trivial if its fundamental cycle is not in the boundary
    subspace generated by triangles (over GF(2)).
    
    Args:
        tree: Spanning tree of the nerve
        nerve: Full nerve graph
        triangles: 2-simplices (triples with non-empty triple intersection)
        
    Returns:
        List of edges (chords) with non-trivial H1 classes
    """
    # Canonical edge sets
    nerve_edges = [_canon_edge(u, v) for (u, v) in nerve.edges()]
    tree_edges = set(_canon_edge(u, v) for (u, v) in tree.edges())
    chords = [e for e in nerve_edges if e not in tree_edges]
    chords = sorted(set(chords))

    e2i = _edge_index(nerve_edges)

    # Build boundary subspace B1 = im(âˆ‚2) from triangle boundaries
    B_pivots: Dict[int, int] = {}
    for tri in triangles:
        b = _triangle_boundary_vec(tuple(sorted(tri)), e2i)
        if b != 0:
            _gf2_insert(b, B_pivots)

    # Choose representatives: keep chord if its class modulo boundaries is independent and nonzero
    H_pivots: Dict[int, int] = {}
    kept: List[Edge] = []
    
    for ch in chords:
        cyc = _fundamental_cycle_vec(tree, ch, e2i)
        cls = _gf2_reduce(cyc, B_pivots)        # mod boundaries
        cls = _gf2_reduce(cls, H_pivots)        # mod already-kept classes
        if cls == 0:
            continue  # boundary / trivial in H1
        _gf2_insert(cls, H_pivots)
        kept.append(ch)

    return kept
